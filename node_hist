x.data
x
x = await client.query({query: GET_TAGS})
await x = client.query({query: GET_TAGS})
await client.query({query: GET_TAGS})
client = new ApolloClient({cache, link})
link = new HttpLink({uri, fetch})
await client.query({query: GET_TAGS})
GET_TAGS = gql`{ tags { id }}`
query
uri = 'http://localhost:8911/graphql'
await client.query({query: GET_TAGS})
client = new ApolloClient({cache, link})
link = new HttpLink({uri, fetch})
uri = 'http://localhost:8911'
uri
await client.query({query: GET_TAGS})
InMemoryCache
GET_POSTS
var GET_POSTS = gql`{ posts }`
await client.query({query: GET_TAGS})
client.query({query: GET_TAGS}).then(r => console.log(r))
GET_TAGS
var GET_TAGS = gql`{tags}`
gql = gt
gt = require('graphql-tag')
client = new ApolloClient({cache, link})
link
var link = new HttpLink({uri, fetch})
fetch = isof
isof = require('isomorphic-fetch')
if = require('isomorphic-fetch')
var link = new HttpLink({uri})
uri = 'http://localhost:8911/graphql'
cache = new InMemoryCache()
HttpLink = alh.HttpLink
InMemoryCache = imc
imc = aci.InMemoryCache
aci
ApolloClient = ac.ApolloClient
ac
alh = require('apollo-link-http')
aci = require('apollo-cache-inmemory')
ac = require('apollo-client')
var client = new ApolloClient({link: z})
const GET_TAGS = gql`{ tags }`
const GET_PAGES = gql`{ tags }`
gql = gt
typeof(gt)
        { tags }`
const GET_PAGES = gql`
var gql = gt.gql
gt = require('graphql-tag')
var ApolloClient = ac.ApolloClient
ac = require('apollo-client')
z = new alh.HttpLink({uri, fetch})
var z
var fetch=f
f
f = require('isomorphic-fetch')
import fetch from 'isomorphic-fetch'
uri = "http://localhost:8911"
const x = new alh.HttpLink({uri: 'http://localhost:8911'})
x = alh.new HttpLink({uri: 'http://localhost:8911'})
alh = require('apollo-link-http')
const link = createHttpLink({ uri: "/graphql" });
let webSocket = new WebSocket('wss://__CLUSTER__.prisma.sh/__WORKSPACE__/__SERVICE__/__STAGE__', 'graphql-subscriptions');
await func()
const func = async () => await db.post.findOne({where: {id: 3}})
const db = new pc.PrismaClient()
pc = require('@prisma/client')
await func()
func()
const func = async () => await db.post.findOne({where: {id: 3}})
const fun = async () => await db.post.findOne({where: {id: 3}})
delete fun
const fun = async () => await db.post.findOne({where: {id: 3}})
db
fun()
fun
const fun = async () => await db.post.getOne({where: {id: 3}})
const db = new pc.PrismaClient()
pc = require('@prisma/client')
(async () => await x())()
x()
x
x().then(i => console.log(i))
x.then(i => console.log(i))
x.then(alert)
typeof(x())
x()
const x = async () => 42
const x = async () => return 42
(async () => await findNames())()
findNames().then(i => console.log(i))
findNames()
    });};
        }, 100);
            res([1,2,3])
        setTimeout(()=>{
    const names= await new Promise((res,rej)=>{
findNames = async () => {
x
x.then(i => console.log(i))
x
x = findNames()
findNames()
};
    console.log('Names:', names);
    });
        }, 100);
            res([1,2,3])
        setTimeout(()=>{
    const names= await new Promise((res,rej)=>{
findNames = async () => {
};
    console.log('Names:', names);
    });
        }, 100);
            res([1,2,3])
        setTimeout(()=>{
    const names= await new Promise((res,rej)=>{
exports.findNames = async () => {
thing().then(i => console.log(i))
thing()
(async () => await db.post.findOne({where: {id: 1}}))()
await thing()
thing()
const thing = async () => { const x = await db.post.findOne({where: {id: 1}}); return x }
const db = new pc.PrismaClient()
pc = require('@prisma/client')
thing()
const thing = async () => { const x = await db.post.findOne({where: {id: 1}}); return x }
const db = new pc.PrismaClient()
pc = require('@prisma/client')
thing()
process.env.DB_HOST = 'file:./api/prisma/dev.db'
process.cwd()
process.env.DB_HOST
thing()
process.env.DB_HOST = 'file:./xx.db'
process.env.DB_HOST = 'file:./dev.db'
thing()
const thing = async () => { const x = await db.post.findOne({where: {id: 1}}); return x }
const thing = async () => { await const x = db.post.findOne({where: {id: 1}}); return x }
const do = async () => { await const x = db.post.findOne({where: {id: 1}}); return x }
const do () => async { await const x = db.post.findOne({where: {id: 1}}); return x }
const do async () => { await const x = db.post.findOne({where: {id: 1}}); return x }
const async do () => { await const x = db.post.findOne({where: {id: 1}}); return x }
async do () => { await const x = db.post.findOne({where: {id: 1}}); return x }
await const x = db.post.findOne({where: {id: 1}})
db.post.findOne({where: {id: 1}})
db.post.findOne({where; {id: 1}})
db.post.findOne({id: 1})
db.post.findOne()
db.post.findOne
db.post
db.posts
db
const db = new pc.PrismaClient()
pc
pc = require('@prisma/client')
import { PrismaClient } from '@prisma/client'
Fred
const { a: Fred } = x
a
const { a } = x
print ...y
...y
y = [1,2,3]
...x
{ a } = ...x
{ a } = x
x = {a:1, b:2, c:3}
x.forEach(i => console.log(i))
x.map(i => i)
x.length
x
x = [1,2,3,,5,,7]
xx.map(i => ({text: i.id, value: i.id}))
xx.map(i => new Object({text: i.id, value: i.id}))
xx.map(i => new Object({text: i.id, value: i.id})
xx.map(i => new Object(text: i.id, value: i.id))
{a:1, b:2}
xx.map(i => {text: i.id, value: i.id})
xx.map(i => i.id)
xx.map(i => i)
xx = JSON.parse(x)
x = '[{"id":"1","name":"wood","__typename":"Tag"},{"id":"2","name":"steel","__typename":"Tag"},{"id":"3","name":"acrylic","__typename":"Tag"},{"id":"4","name":"woodworking","__typename":"Tag"},{"id":"5","name":"brass","__typename":"Tag"}]'
x = [{"id":"1","name":"wood","__typename":"Tag"},{"id":"2","name":"steel","__typename":"Tag"},{"id":"3","name":"acrylic","__typename":"Tag"},{"id":"4","name":"woodworking","__typename":"Tag"},{"id":"5","name":"brass","__typename":"Tag"}]
x = "[{"id":"1","name":"wood","__typename":"Tag"},{"id":"2","name":"steel","__typename":"Tag"},{"id":"3","name":"acrylic","__typename":"Tag"},{"id":"4","name":"woodworking","__typename":"Tag"},{"id":"5","name":"brass","__typename":"Tag"}]"
[].join('x')
z
y
x
x.push(5)
z = x.slice()
y
x
x.push(4)
y === x
y == x
y = x
x = [1,2,3]
x = 1,2,3]
{}.length()
{}.length
[].length
x.size
x.length
{}.length()
{}.length
x ? 1 : 2
x = {}
x = Set([1,2,3])
new Set()
Set()
x.delete(55)
x
x.delete(3)
x - 3
x
x = new Set([1,2,3,4])
x = newSet([1,2,3,4])
x
[...x].reduce((prev, curr) => [...prev, { name: curr }], [])
x = new Set()
x
x.a = 12
x = {}
zzz
if (true) { zzz = 3 }
z.size
z.length
Boolean(z)
Boolean(3)
Bool(z)
z ? 1 : 0
z = new Set()
[...xx].reduce((prev, curr) => prev + (prev ? ' ' : '') + curr, '')
[...xx].reduce((prev, curr) => prev + (prev : ' ' ? '') + curr, '')
[...xx].reduce((prev, curr) => prev + ' ' + curr, '')
xx.reduce((prev, curr) => prev + ' ' + curr, '')
xx
xx = new Set(x.split(','))
new Set(z.split(','))
z = undefined
new Set(y.split(','))
new Set(x.split(','))
y = ''
x = "a,b,c"
if (1 or 2) { return x }
if (1 or 2) x
[].length
[].isEmpty()
if (x === []) console.log(2)
x = []
if ([] === []) console.log(2)
if ([] == []) console.log(2)
if ([]) console.log(2)
if [] console.log(2)
x.reduce((prev, curr) => [...prev, curr.name], start)]
new Set([...spre].filter(x => !spost.has(x)))
new Set([...spre].filter(x => spost.has(x)))
spre.keys()
spre
spre.intersection(spost)
spost = new Set(post)
spre = new Set(pre)
post = [4,5,6,7,8]
pre = old
new = [4,5,6,7,8]
old = [1,2,3,4,5]
if (tags) { console.log(123) }
tags = ''
x ||= ''
x = ''
x
x |= ''
x = ''
"" || 2
"" or 2
"".split(",")
for (const t of x) { console.log(t) }
x = []
for (const t of x) { console.log(t) }
for (const t of x.split(',')) { console.log(t) }
x = ['a', 'b']
for (const t of x.split(',')) { console.log(t) }
for (const t of x.split(',')) => console.log(t)
x.split(',')
x = ''
x
x |= 2
x | 2
x
x = undefined
tags.join(',')
tags = ['a', 'b', 'c']
tags.map((t) => t.name).join(',')
tags.map((t) => t.name)
map(tags, t => t.name)
tags.join(',')
','.join(tags)
tags
tags.reduce((prev, curr) => [...prev, curr.name], [])
tags = [{name: 'a'}, {name: 'b'}, {name: 'c'}]
x.reduce((prev, curr) => [...prev, curr.name], ['GUMP'])
x.reduce((prev, curr) => [...prev, curr.name], [])
x = [{name: 'frred'}, {name: 'sallee'}, {name: 'nob'}]
x.a.map
x.z
x.a
x
x = {a: {b: 33}}
((x) => 2*x)(3)
(() => 2)()
() => 2
b
a
a, b = b, a
b = 2
a = 1
true * 7
3 + true
3 + false
2 - true
x`2`
x(2)
const x = a => a + ' whatever'
const x = a => return a + ' whatever'
!('b' in x)
'b' not in x
'b' in x
'a' in x
x = {a:1, z: 2}
Object.entries(x).length
x = {}
x.length
x = {a: 1}
x.length
x = {}
x.length
x = []
x.length
x = [1,2,3]
+[] == false
=[] == false
+x == false
x == false
x = {}
boolean(1)
bool(1)
].reduce((acc, cur) => ({ ...acc, [cur.color]: cur.id }), {})
  { id: 30, color: "green" }
  { id: 20, color: "blue" },
  { id: 10, color: "red" },
[
x
let x = (2, 3)
let x = 2, 3
url.parse('http://a@b.com/item/?x=1')
url.parse('http://a@b.com/item?x=1')
url.parse('http://a@b.com/item/')
url.parse('http://a@b.com/item')
require('react');
require 'react'
require react
import React, { Component } from "react";